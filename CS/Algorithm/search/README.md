### ◈ Binary Search(이진 탐색, 이분 탐색)

- 정렬이 되어있는 탐색할 자료를 둘로 나누어 해당 데이터가 있을만한 곳을 탐색하는 방법.
- 순차 탐색은 앞에서부터 차례로 비교해 O(n)의 시간복잡도를 갖는데 반해 이진 탐색은 2로 계속 나누어 O(logn)의 시간복잡도를 가진다.
- 장점 : 시간 복잡도가 짧은 편
- 단점 : 트리의 형태에 의존?

**분할 정복** 

분할: 하나 또는 둘 이상으로 나눈다

정복: 나눠진 문제가 충분히 작고 해결 가능하면 해결. 그렇지 않으면 또 분할

**이진 탐색(분할 정복의 한 종류?)**

분할: 두 개의 서브 리스트로 나눈다.

정복: 검색 데이터보다 작으면 앞부분의 서브 리스트에서, 검색 데이터보다 크면 뒷부분의 서브 리스트에서 데이터를 찾는다.

### ◈ Hash Table(해시 테이블)

- 파이썬 딕셔너리 타입과 같이 키(Key)에 데이터(Value)를 저장하는 데이터 구조
- 해시 테이블은 클러스터 사이즈에 의존한다.해쉬 테이블은 리스트로 관리되는데 충돌될 가능성이 큼.
- 주요 용도
    - 검색이 많이 필요한 경우
    - 저장, 삭제, 읽기가 빈번한 경우
    - 캐쉬 구현시 (중복 확인이 쉽기 때문)
- 장점
    - 데이터 저장/읽기 속도가 빠르다. (검색 속도가 빠르다.)
    - 해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉬움
- 단점
    - 일반적으로 저장공간이 좀더 많이 필요하다.
    - **여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요함**
- 충돌 해결 기법 종류
    - **Chaining 기법**
        - **개방 해슁 또는 Open Hashing 기법** 중 하나.
        - 해쉬 테이블 저장공간 외의 공간을 활용하는 기법.
        - 충돌이 일어나면, 링크드 리스트라는 자료 구조를 사용해서, 링크드 리스트로 데이터를 추가로 뒤에 연결시켜서 저장하는 기법
            
            → 일반 단순 리스트로 사용할 때 추가하는 과정(logn) 연결 리스트로 이을경우 log1로 추가된다. 많이 연결되면 시간이 줄어든다. 검색 시간복잡도 
            
    - **Linear Probing 기법**
        - **폐쇄 해슁 또는 Close Hashing 기법** 중 하나
        - 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법. 충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈공간에 저장하는 기법
        - 저장공간 활용도를 높이기 위한 기법
    - 그 외 기법
        - 해쉬 함수를 재정의 및 해쉬 테이블 저장공간을 확대해 빈번한 충돌을 개선한다.

### ◈ Depth First Search(DFS, 깊이 우선 탐색)

DFS 알고리즘 작동원리

재귀함수를 이용하거나 **스택(자료구조 설명, pop)**으로 구현.

1. 재귀 함수: 방문 확인 리스트와 인접리스트,  시작점과 인접한 곳을 방문하지 않았다면  방문 처리하고 깊이로 들어가 또 그 노드와 인접한 곳을 찾아 방문 처리 재귀적으로 반복.

2. 스택 사용 : 탐색 시작 노드를 스택에 삽입하고 방문 처리. 인접한 노드 중 현재 방문할 노드를 스택에 넣고 방문 처리. 방문할 인접노드가 없을 때 스택에서 꺼내서 다시 인접노드 확인

무한하게 깊이가 들어가지 않기 위해 깊이 제한을 사용한다. 검색할 데이터를 찾지 못한 채 깊이 제한에 걸리면 돌아와서 다시 제한에 안걸리는 부모 노드부터 재검색

- 용도 : 모든 노드를 탐색해야 할 때 사용
- 장점 : 현 경로의 노드만 기억하므로 저장공간의 수요가 비교적 적다.
- 단점 : 찾는 데이터가 없을 경로에도 깊이 빠진다. 최적의 경로로 데이터를 찾지 않는다.
- 시간 복잡도 :
    - 노드 수: V
    - 간선 수: E
    while 문 반복으로 V + E 만큼 수행하므로 O(V + E)의 시간 복잡도를 갖는다.
    

### ◈ Breadth First Search(BFS, 너비 우선 탐색)

BFS 알고리즘 구현

깊이가 가장 얕은 노드부터 모두 탐색한 뒤 깊이가 깊은 노드를 탐색하는 방법.

방문 확인 리스트와 **큐(popleft. append) → 디큐(큐와 스택의 장점을 합쳐놓은 자료구조,** list 인덱스 접근, 시간속도 면에서 빠름. extend 추가**)** 자료 구조를 생성해 큐에는 초기 시작점을 넣어준다. 하나씩 꺼내면서 인접한 노드를 큐에 더해준다. 용도 : 최단경로나 답의 방법이 많을 때

- 시간 복잡도 :
    - 노드 수: V
    - 간선 수: E
    
    while 문 반복으로 V + E 만큼 수행하므로 O(V + E)의 시간 복잡도를 갖는다.
