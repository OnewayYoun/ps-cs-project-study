# 해시 테이블

## 1. 해시 테이블(Hash table)

해시 테이블은 `(key, value)`쌍을 원소를 갖는 컬렉션입니다. `key`의 경우, 해시함수의 입력으로 사용되며, 이에 대한 결과값은 해시 테이블의 인덱스로 사용됩니다. 다음은 해시 테이블의 가장 간단한 예시로 `(key, value)`쌍, 해시 테이블의 크기, 해시 함수가 정의 되어있습니다.

<br/>

* `(17, "apple")`, `(15, "banana")`, `(151, orange)`
* 해시 테이블의 크기: 5
* 해시 함수: h(x) = x % 5

<br/>

3개의 `(key, value)`쌍을 해시테이블에 넣기위해 아래의 과정을 거칩니다.

* h(17) = 17 % 5 = 2
* h(15) = 15 % 5 = 0
* h(151) = 151 % 5 = 1

따라서 해시 테이블은 다음과 같은 모습을 띄우게 됩니다.<br/>

| index |   해시 테이블   |
| ----- | :-------------: |
| 0     | (15, "banana")  |
| 1     | (151, "orange") |
| 2     |  (17, "apple")  |
| 3     |                 |
| 4     |                 |

<br/>

위의 테이블에서 추가적으로 `(150, "grape")`를 넣는다고 하면 어떻게 될까요? 바로 충돌이 일어납니다. 그러면 아래의 챕터에서 해시 충돌에 대해 배워봅시다.<br/>

## 2. 해시 충돌(Hash Collision)

해시 충돌은 다른 키를 해시 함수에 입력하여 동일한 출력 결과가 나왔을 때 발생하는 현상입니다. 다시 말해, 들어갈 인덱스가 중복되었다는 것이죠. `(150, "grape")` 이 들어갈 자리는 인덱스 `0`입니다. 하지만 인덱스 `0`에는 `(15, banana)`가 들어있죠. 그러면 어떻게 하면 해시 충돌을 줄일 수 있을까요?

해시 충돌을 피하기 위한 가장 단순한 생각으로 **해시 함수를 잘 설계**하는 것이죠. 어떻게 하면 해시 함수를 잘 설계했다고 할 수 있을까요? 바로 **1:1 관계**를 갖는 해시 함수를 설계하는 것입니다. 하지만 현실적으로 쉽지않습니다. 대안으로, 다른 키를 해시 함수에 입력했을 때, 동일한 출력 결과가 나오는 확률이 **`C / M`**인 해시 함수를 설계하는 것입니다.(`C`는 상수, `M`은 해시 테이블의 크기) <br/>

해시 충돌을 줄이기 위한 2번째 방법으로 **해시 테이블의 일부만 사용하는 것**입니다. 직관적으로 10의 크기를 갖는 해시 테이블에서, 9개의 `(key, value)`쌍을 갖고있고, 여기서 추가적으로 새로운 `(key, value)`쌍을 삽입하게 된다면, 충돌날 확률이 높습니다. 반대로, 3개의 `(key, value)`쌍이 들어있는 해시 테이블에서 새로운 `(key, value)`쌍을 삽입할 때, 해시 테이블를 확장하여 20의 크기를 갖고 그 다음에 `(key, value)`쌍을 삽입하면 충돌이 날 확률은 많이 줄어듭니다.<br/>

핵심은 충돌날 확률을 줄이는 것이지, 충돌을 없애는 것이 아닙니다. 그렇다면, 해시 충돌이 발생했을 때, 우리는 어떻게 해결해야 할까요? 다음 챕터에서 확인해봅시다.

<br/>

## 3. 해시 충돌 해결 방법(Hash Collision Resolution Method)

해시 충돌을 위한 해결방법으로 크게, **Open addressing**, **Chaining**의 방법이 있습니다. **Open addressing**은 해시 충돌이 일어날 경우, 원소가 없는 인덱스를 찾아서, 해당 인덱스에 삽입하는 방법입니다. Open addressing를 실현한 방법으로 **Linear probing**, **Quadratic probing**, **Double hashing**이 있습니다. **Chaining**의 경우, 각 원소의 자료구조로 리스트를 사용합니다. 따라서 충돌이 난 인덱스에서 삽입할 `(key, value)`쌍을 리스트에 삽입합니다.<br/>

Chaining의 쉬운 설명을 위해, 위에서 사용된 해시 테이블을 사용하겠습니다. `(150, "grape")`를 삽입하게 될 경우, 정의된 해시 함수에 의해 해시 충돌이 발생하게 됩니다. 그러면 인덱스 `0`에서의 리스트에서 `(150, "grape")`를 삽입합니다. 따라서 인덱스 `0`에서의 원소는 `(15, "banana")->(150, grape)`형태를 띄웁니다.<br/>

Open addressing 방법 중 하나인 Linear probing에 대해 살펴봅시다. Linear probing은 해시 충돌이 발생했을 때, 그 다음 인덱스가 비어있는지 확인합니다. 비어있으면 해당 인덱스에 `(key, value)`쌍을 삽입하고, 비어있지 않으면 비어있는 인덱스를 찾을 때까지, 선형적으로 탐색합니다. Linear probing은 아이디어가 단순하지만, 인덱스를 연속해서 사용한다는 단점이 있습니다. 연속적으로 점유된 인덱스는 사용할 수 없기 때문에 탐색 시간이 길어지기 때문입니다. 연속적으로 점유된 인덱스가 많아질수록 해시 충돌이 발생할 확률이 커집니다.<br/>

위에서 사용된 해시 테이블을 예를들어 설명해보겠습니다. `(150, "grape")`를 해시 테이블에 삽입하면 정의된 해시 함수에 의하여, 인덱스 `0`으로 들어가야 하지만, 해시 충돌이 발생하여 들어 갈 수 없습니다. 따라서 다음 인덱스, `1`를 탐색합니다. 인덱스 `1`은 점유되고 있으므로 해시 충돌이 발생했습니다. 따라서 다음 인덱스 `2`를 탐색합니다. 인덱스 `2`는 점유되고 있으므로 해시 충돌이 발생했습니다. 따라서 다음 인덱스 `3`을 탐색합니다. 인덱스 `3`은 비어있으므로 여기에 `(150, "grape")`를 삽입합니다.<br/>

위의 사실로 부터, 연속적으로 점유되고 있는 인덱스가 길어지면, 해시 충돌이 계속 발생한다는 것을 확인했습니다. 따라서 이를 보완해야하는데, 그것이 바로 Quadratic probing입니다.<br/> 

Quadratic probing은 충돌이 났을때, 비어있는 인덱스를 찾기 위해, 선형적으로 탐색하는 것이 아닌, 여러 칸을 뛰어서 탐색합니다. 따라서 `(key, value)`쌍이 분산적으로 저장됩니다. 이렇게 되면 새로운 `(key, value)`쌍이 올 때, 충돌 확률을 줄일 수 있습니다.<br/>

한편, Double hashing은 해시 함수를 2개 사용해서 해시 충돌을 해결하는 방법입니다. 각각의 해시 함수, `f`, `g`가 있다고 합시다. 만약 `f`에 의해 해시 충돌이 나면, `key`를 `g`에 입력하여 나온 결과를 `f`와 더해줍니다. 만약 여기서도 충돌이 나면, `g`를 한 번 더 더해줍니다. 충돌이 나지 않을 때까지, `g`를 계속 더해줍니다. Double hashing의 문제점은 해시 함수를 2개 설계해야하는 것 그리고 충돌이 날 경우, 2번의 해시 연산이 있다는 것입니다.

